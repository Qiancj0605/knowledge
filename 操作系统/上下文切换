#上下文
任务运行前，CPU需要知道任务从哪里加载，从哪里开始运行，也就是CPU寄存器和程序计数器，这两个是CPU运行任务前都必须依赖的环境，叫做CPU上下文。

#上下文切换
上下文切换的步骤；
  1、将前一个CPU执行任务的上下文(CPU寄存器和程序计数器的内容)保存起来；
  2、加载新任务的上下文到寄存器和程序计数器；
  3、跳转到程序计数器所指的位置，开始运行新任务。
被保存起来的上下文会存储到系统内核中，等待任务重新调度时再次加载进来。
CPU上下文切换分为三种：进程上下文切花、线程上下文切换和中断上下文切换。

#系统调用
Linux按照系统特权等级，把进程运行空间分为内核空间和用户空间：
  内核空间：具有最高访问权限，可访问全部资源
  用户空间：只能访问部分资源，不能直接访问系统资源，必须借助系统调用进行访问。
进程可以在用户空间运行(进程用户态)，也可以在内核空间运行(进程内核态)。从用户态到内核态需要系统调用完成。该过程会发生CPU上下文切换，
CPU寄存器会先保存用户态的状态，然后加载内核态相关内容；系统调用结束后，CPU寄存器要恢复原来保存的用户态，再进行一次CPU上下文切换。所以该过程发生两次CPU上下文切换。
需要特别注意的是，系统调用过程中，不涉及虚拟内存等用户态资源，也不会切换进程，与一般的进程上下文切换有所不同：
  进程上下文切换一般指：从一个进程切换到另一个进程；
  系统调用过程：一直在同一个进程中运行。
  
#进程上下文切换
进程是由内核管理和调度的，进程切换只发生在内核态。因此进程上下文切换不但包括虚拟内存、栈等用户态资源，还包括内核堆栈、寄存器、程序计数器等内核状态。所以进程上下文切换比系统调用
多一个步骤：保存当前进程的内核态之前，先把进程的虚拟内存、栈等保存起来；加载下一个进程的内核态后，还需要刷新进程的虚拟内存和栈。保存上下文和恢复上下文需要内核在CPU上运行才能完成。
Linux会为每个CPU维护一个就须队列，将活跃进程（正在运行和正在等待的进程）按照优先级和等待CPU的时间来排序，选择最需要的CPU进程，也就是优先级最高和等待CPU时间最长的进程来运行。
进程切换时需要切换上下文，进程切换的场景：
  1、进程时间片用完；
  2、系统资源不足(比如内存)；
  3、进程通过函数sleep挂起自己；
  4、为了运行更高优先级的进程；
  5、发生中断，CPU进程被挂起，去执行内核中的中断服务进程。
  
#线程上下文切换
内核中的任务调度实际是调度线程(线程是调度基本单位)，进程给线程提供基本资源(如虚拟内存、栈、全局变量等)。线程上下文切换，共享的虚拟内存恶化全局变量不需要修改，但线程似有数据(栈和寄存器)需要保存。
线程切换：
  1、同一个进程下的线程切换；
  2、不同进程下的线程切换(牵涉进程切换)。
  
#中断上下文切换
为了快速响应特定事件，中断处理会打断进程的正常调度和执行，然后调用中断处理程序。打断时，需要先把进程当前状态保存下来，中断结束后，进程再恢复之前状态。
和进程上下文不同，中断上下文切换不涉及进程的用户态。因此，中断过程打断一个正在运行的用户态进程，也不需要保存和恢复用户态资源(进程虚拟内存等)，中断上下文只包含内核态中断服务程序所必须的状态(CPU寄存器，内核对堆栈)。
